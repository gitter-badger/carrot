<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>layer.js - Documentation</title>
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Connection.html">Connection</a></li><li><a href="Group.html">Group</a></li><li><a href="Layer.html">Layer</a><ul class='members'><li data-type='member'><a href="Layer.html#.activate">activate</a></li><li data-type='member'><a href="Layer.html#.next">next</a></li><li data-type='member'><a href="Layer.html#.previous">previous</a></li><li data-type='member'><a href="Layer.html#.propagate">propagate</a></li><li data-type='member'><a href="Layer.html#.weights">weights</a></li></ul><ul class='methods'><li data-type='method'><a href="Layer.html#connected">connected</a></li><li data-type='method'><a href="Layer.html#neurons">neurons</a></li><li data-type='method'><a href="Layer.html#project">project</a></li><li data-type='method'><a href="Layer.html#reset">reset</a></li></ul></li><li></li><li><a href="Neuron.html">Neuron</a><ul class='methods'><li data-type='method'><a href="Neuron.html#clear">clear</a></li><li data-type='method'><a href="Neuron.html#connected">connected</a></li><li data-type='method'><a href="Neuron.html#reset">reset</a></li><li data-type='method'><a href="Neuron.html#selfconnected">selfconnected</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="Layer_Layer_can.html">can</a><ul class='methods'><li data-type='method'><a href="Layer_Layer_can.html#.activate">activate</a></li><li data-type='method'><a href="Layer_Layer_can.html#.propagate">propagate</a></li></ul></li><li><a href="Layer_Layer_has.html">has</a><ul class='methods'><li data-type='method'><a href="Layer_Layer_has.html#.activated">activated</a></li><li data-type='method'><a href="Layer_Layer_has.html#.propagated">propagated</a></li></ul></li><li><a href="Layer_Layer_is.html">is</a><ul class='methods'><li data-type='method'><a href="Layer_Layer_is.html#.input">input</a></li><li data-type='method'><a href="Layer_Layer_is.html#.output">output</a></li></ul></li><li><a href="Neuron.squash.html">squash</a><ul class='methods'><li data-type='method'><a href="Neuron.squash.html#.HLIM">HLIM</a></li><li data-type='method'><a href="Neuron.squash.html#.IDENTITY">IDENTITY</a></li><li data-type='method'><a href="Neuron.squash.html#.LOGISTIC">LOGISTIC</a></li><li data-type='method'><a href="Neuron.squash.html#.RELU">RELU</a></li><li data-type='method'><a href="Neuron.squash.html#.TANH">TANH</a></li></ul></li><li><a href="Neuron_Neuron_is.html">is</a><ul class='methods'><li data-type='method'><a href="Neuron_Neuron_is.html#.connected">connected</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#_trainSet">_trainSet</a></li><li><a href="global.html#activate">activate</a></li><li><a href="global.html#inputs">inputs</a></li><li><a href="global.html#LayerConnection">LayerConnection</a></li><li><a href="global.html#neurons">neurons</a></li><li><a href="global.html#outputs">outputs</a></li><li><a href="global.html#Perceptron">Perceptron</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#restore">restore</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#train">train</a></li><li><a href="global.html#XOR">XOR</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">layer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

let _ = require('lodash')

let Network = require('./network')
let Neuron = require('./neuron')

/**
* @param {Neuron} from
* @param {Neuron} to
* @param {string} type
* @param {number} weight
* @param {Object} options
* @param {number} options.ID
* @param {Object} options.connections
* @param {Neuron[]} options.list
* @param {number} options.size
* @param {Neuron[]} options.gatedfrom
*/
let LayerConnection = function(from, to, type = Layer.connectionType.ALL_TO_ALL, weights, {
  ID = LayerConnection.uid(),
  connections = {},
  list = [],
  size = 0,
  gatedfrom = [],
} = {}) {
  let self = this;
  
  _.assignIn(self, { ID, from, to, type, connections, list, size, gatedfrom });
  
  self.selfconnection = to == from;

  if(from == to) self.type = Layer.connectionType.ONE_TO_ONE;

  if(self.type == Layer.connectionType.ALL_TO_ALL || self.type == Layer.connectionType.ALL_TO_ELSE) {
    _.each(self.from.list, function(from) {
      _.each(self.to.list, function(to) {
        if(self.type == Layer.connectionType.ALL_TO_ELSE &amp;&amp; from == to) return;

        let connection = from.project(to, weights);

        self.connections[connection.ID] = connection;
        self.size = self.list.push(connection);
      })
    })
  } else if(this.type == Layer.connectionType.ONE_TO_ONE) {
    _.each(self.from.list, function(from, index) {
      let connection = from.project(self.to.list[index], weights);
      
      this.connections[connection.ID] = connection;
      this.size = this.list.push(connection);
    })
  }

  from.connectedTo.push(this);
}

/**
* @constructs Layer
* @param {number} size
* @param {Object} [options]
* @param {number} [options.bias]
* @param {number} [options.rate=0.3]
* @param {number} [options.weight]
* @param {SquashFunction} [options.squash]
*/
let Layer = function(size = 0, {
  list = [],
  connectedTo = [],
} = {}) {
  _.assignIn(this, { list, connectedTo })
  this.size = size;

  while (size--) {
    let neuron = new Neuron();
    this.list.push(neuron);
  }

  /**
  * @param {number[]} [input]
  * @returns {number}
  */
  self.activate = function(input) {
    return _.map(self.neurons, function(neuron, index) {
      if(!_.isNil(input)) return neuron.activate(input[index]);
      else return neuron.activate();
    })
  }

  /**
  * @param {number[]} [target]
  */
  self.propagate = function(target) {
    _.each(self.neurons, function(neuron, index) {
      if(!_.isNil(target)) neuron.propagate(target[index]);
      else neuron.propagate();
    })
  }

  /** 
  * Projects this layer to given layer
  *
  * @param {Layer|Network} layer
  * @param {String} [type]
  * @param {number[]} [weights]
  */
  this.project = function(layer, type, weights) {
    if(layer instanceof Network) layer = layer.layers.input;

    if(layer instanceof Layer) {
      if(!this.connected(layer)) return new LayerConnection(this, layer, type, weights);
    } else throw new Error('Invalid argument, you can only project connections to LAYERS and NETWORKS!');
  }
  
  /** 
  * Return true iff this layer is connected to given layer
  */
  this.connected = function(layer) {
    // Check if ALL to ALL connection
    let connections = 0;
    _.each(this.list, function(from) {
      _.each(layer.list, function(to) {
        let connected = from.connected(to);
        if(connected.type == 'projected') connections++;
      })
    })
    if(connections == this.size * layer.size) return Layer.connectionType.ALL_TO_ALL;

    // Check if ONE to ONE connection
    connections = 0;
    _.each(this.list, function(from, index) {
      let connected = from.connected(layer.list[index]);
      if(connected.type == 'projected') connections++;
    })
    if(connections == this.size) return Layer.connectionType.ONE_TO_ONE;
  }
  
  /** 
  * Resets all connection weights to/from the layer
  */
  this.reset = function() {
    _.each(this.list, function(neuron) { neuron.reset() })
  }
  
  /**
  * Returns all layer neurons
  *
  * @returns {Neuron[]}
  */
  this.neurons = function() {
    return this.list;
  }
}

module.exports = Layer</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Mar 18 2019 02:40:40 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>




</body>
</html>
